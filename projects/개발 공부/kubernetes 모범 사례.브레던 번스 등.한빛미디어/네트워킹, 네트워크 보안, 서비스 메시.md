### 생성 날짜: 2024-04-04T21:26
### 주제: 네트워킹, 네트워크 보안, 서비스 메시
---
### 본문:

## 쿠버네티스 네트워크 원칙
### 동일한 파드 내의 컨테이너 간 통신
>동일한 파드 내의 모든 컨테이너는 동일한 네트워크 공간을 공유합니다. P.166

즉, localhost를 사용하여 통신이 가능하다는 것이고, 이는 중복된 포트를 사용하지 않도록 유의해야한다는 것을 뜻한다. ex) spring boot with actuactor (8080, 8081)

![[Internal-network-pod.png]]

### 파드 간의 통신 
> 즉, 수신하는 파드에서 볼 수 있는 송신자의 파드 IP 주소가 실제 IP 주소입니다. P.166

파드 간의 통신은 실제 IP 주소를 사용하여 정보를 주고 받는다.

### 서비스와 파드 간의 통신

> 주로 iptables을 이용하는 방법과 IP 가상 서버를 이용하는 방법이 있습니다. P.167

iptables는 리눅스 커널의 넷필터 프레임워크를 사용하여 패킷 필터링, 네트워크 주소 변환(NAT) 및 포트 전송과 같은 다양한 네트워크 관련 작업을 수행하는 도구입니다. 쿠버네티스에서는 iptables를 사용하여 파드 간, 그리고 외부 네트워크와의 통신을 제어합니다.

IPVS (IP Virtual Server)는 리눅스 커널 내에 구현된 고성능 로드 밸런서입니다. IPVS는 L4(전송 계층)에서 작동하며, 높은 처리량과 대규모 서비스의 로드 밸런싱을 위해 설계되었습니다. iptables 기반의 로드 밸런싱보다 더 효율적이고 확장 가능한 로드 밸런싱 솔루션을 제공합니다.
## Ingress and Selector

Ingress는 http 수준의 라우터로 외부 요청을 내부 서비스에 라우팅한다. 라우팅된 서비스는 Selector를 활용하여 어떤 파드에 요청을 보내야하는지 결정한다.

Selector는 label, namespace 등을 활용하여 팟을 결정한다.
![[ingress-and-selector.png]]
selector는 pod와 service를 연계한다고 하는데 client는 요청을 보낼 때 namespace를 같이 보내지 않는다 그렇다는 것은 service, pod는 항상 metadata에 namespace를 가져야하는 것이고, 이것을 selector라는 것이 관제를 하는데.

selector가 전체 클러스터의 namespace를 관리하는 개념이 아니라 service 마다 selector가 있는 형식이라면 service 간에 pod의 namespace가 중복되는 것은 가능한 상태로 해석된다.

## 네트워크 플로그인

> kubenet은 쿠버네티스에서 바로 사용할 수 있는 가장 기본적인 네트워크 플러그인입니다. ... 파드가 연결되면 클러스터의 노드에 분산되어 있는 CIDR 범위 내의 IP 주소를 얻게 됩니다. p.169

kubenet을 잘 사용하기 위해서는 아래 항목을 확인해야합니다.
- 파드 CIDR 범위가 각 클러스터의 파드의 잠재적인 최대 크기를 처리할 만큼 충분히 큰지 확인해야합니다.
	- 기본 설정은 110이다.
- 적합한 노드의 파드로 트래픽이 전송될 수 있도록 경로 규칙을 이해하고 올바른 계획을 세워야합니다.

## CNI 플러그인 모범 사례
쿠버네티스는 내부적으로 http 요청을 사용하기 때문에 클러스터 내부적으로 외부적으로 통신의 안정성과 신뢰성을 확보해야한다.

저자가 설명하는 CNI 플러그인 사용 시 유의해야하는 사항은 다음과 같다.
- 인프라의 전반적인 네트워킹 목표를 달성하는 데 필요한 기능을 평가해야합니다.
	- 고가용성, 다중 클러스터 등 요구사항에 따라 필요한 기능을 선별해야한다. 성능과 안정성은 언제나 트레이프 오프이기 때문에
- 공개 클라우드 공급자로 실행 중이라면 공급자의 소프트웨어 정의 네트워크가 CNI 플러그인을 지원하는지 알아봐야한다.
- 네트쿼으 보안 도구, 네트워크 관찰성, 관리 도구가 CNI 플러그인을 지원하는지 조사해야한다.
- SDN 네트워크 공간과 분리된 별도의 오버레이 네트워크를 제공하지 않는 CNI를 사용하는 경우 충분한 네트워크 주소 공간이 있는 지 확인해야한다.
## 쿠버네티스의 서비스

> 파드는 오직 같은 클러스터 내의 다른 파드와 직접 통신할 수 있습니다. p.171

그렇기 때문에 로컬에서 프로젝트 실행 시에 port-forwarding을 진행해야한다고 생각한다. 
만약 팀 마다 클러스터가 생성되어 있다면 로컬에서 프로젝트를 실행 시킬 수는 있는 것인가???

> hint: 노드와 동일한 네트워크 공간의 IP를 파드에 부여하는 CNI 플러그인이라면 기술적으로는 파드 IP를 알면 클러스터 외부에서 직접 접근할 수 있습니다. p.171

> 쿠버네티스는 새로운 이름과 IP 주소로 대체 파드를 생성하므로 이를 찾을 수 있는 메커니즘이 필요합니다. p.171

Q: 매번 새로운 이름과 IP 주소가 생겨난다면 모든 이름과 IP 주소를 관리하는 서비스가 필요하다고 생각하는데 어떤 서비스에서 namespace를 ip주소로 변환하는 것인지?

core-dns 라는 기술을 사용하여 관리한다. ([관련 문서](https://kubernetes.io/ko/docs/tasks/administer-cluster/coredns/))
### 지선생
```
- **CoreDNS (또는 Kube-DNS)**: 쿠버네티스 클러스터 내의 DNS 서버 역할을 하며, 서비스의 이름을 IP 주소로 매핑합니다.
- **DNS 레코드 관리**: 쿠버네티스 서비스 생성 시 자동으로 DNS 레코드가 등록되어, 이름 기반으로 서비스에 접근할 수 있게 합니다.
- **네임스페이스와 DNS**: 네임스페이스를 포함한 FQDN을 통해 동일한 이름의 서비스를 구분하여 접근할 수 있습니다.
```
## ClusterIP 서비스 타입

같은 네임스페이스에 존재한다면 `http://<namespace>`로 호출 가능 같은 노드 다른 네임스페이스에 존재한다면 `http://<service_name>.<namespace>.svc.cluster.local`로 요청을 전송할 수 있다.

셀렉터가 없다면 엔드포인트를 관리할 수 있는 pod을 하나 새롭게 생성하여 커스텀하게 관리할 수 있다는 것을 의미하는 것 같은데 셀렉터가 없는 경우가 없도록 하는 것이 더 유용한 것이 아닌지

## NodePort 서비스 타입

> NodePort 서비스 타입은 클러스터의 각 노드의 고수준 포트를 각 노드의 서비스 IP와 포트에 할당합니다. p.173

Q: 어떻게 고수준 포트로 불릴 수 있는 것인지?
클러스터 외부에서 특정 서비스에 바로 접근할 수 있도록 한다. 때문에 인그레스, 서비스 등 여러 내부적인 서비스를 거치지 않고 바로 접근 가능하기 때문에 고수준이라고 불린다.
### 지선생
```  
쿠버네티스에서 `NodePort` 타입의 서비스(Service)는 클러스터 밖에서 내부 파드(Pod)에 접근할 수 있도록 하는 방법 중 하나입니다. 이 서비스 타입을 사용하면, 쿠버네티스 클러스터의 모든 노드(Node)에 있는 특정 포트(`NodePort`)를 통해 서비스에 접근할 수 있게 됩니다. `NodePort` 서비스는 내부 파드에 할당된 포트와는 별개로, 클러스터의 모든 노드에 걸쳐 고정된 포트(`NodePort`)를 제공합니다.
```

## ExternalName 서비스 타입
> 클러스터 수준의 내구성을 가진 DNS 이름을 외부 DNS 서비스에 전달할 때 유용합니다. p.175

외부 데이터베이스를 사용할 때 내부적으로는 쿠버네티스의 namespace를 사용하여 관리되고, 해당 namespace에 요청이 들어오면 ExternalName에 정의된 url로 요청이 가도록 설정하고 싶은 경우 사용할 수 있을 것 같다. 

온프레미스 환경에서 서비스를 구축한다면 사용할 수 있을까?

## 로드 밸런서 서비스 타입
클러스터 외부에서 Pod에 네트워크 트래픽을 자동으로 분산시키는 역할을 합니다. 이 서비스 타입을 사용하면, 클라우드 제공업체가 제공하는 외부 로드 밸런서를 자동으로 프로비저닝하고 구성하여, 외부에서 클러스터 내부의 특정 서비스로 접근할 수 있도록 하는 것으로 이해가 되는데.

인그레스를 거치지 않고, 특정 서비스로 접근해야하는 이유가 무엇인지??

## 인그레스와 인그레스 컨트롤러

> 높은 수준의 트래픽 관리가 필요합니다. 일반적으로 애플리케이션 수준의 제오, 특히 HTTP 프로토콜을 관리해야합니다. p.177

외부에서 들어오는 요청에 대해 빠르게 통신을 해야하기 때문에 http로 통신하는 것으로 이해가 된다.

ingress API의 특징
1. 호스트 기반 라우팅을 허용해 단일 인그레스에서 여러 호스트를 지원합니다.
2. 포트 443에서 TLS 종료에 대한 인증서 정보를 가진 쿠버네티스 시크릿을 선언합니다.
3. 경로를 지정하지 않은 경우, 표준 404 오류보다 더 나은 UX를 제공하는 기본 백엔드가 있습니다.

> 인그레스 컨트롤러는 다른 쿠버네티스 컨트롤러와 마찬가지로 컨트롤러지만 시스템의 일부가 아니며, 동적 구성을 위한 쿠버네티스 인그레스 API와 인터페이스하는 서드파티 컨트롤러입니다. p.178

사용자가 정의하기 나름이다.

## 서비스와 인그레스 컨트롤러 모범 사례
- 노출해야하는 서비스가 주로 http/https 기반이라면 인그레스 API와 컨트롤러를 사용하여 TLS 종료와 함께 트래픽을 서비스로 라우팅하는 것이 좋습니다.
- 웹 기반 워크로드의 안전한 수신에 필요한 기능을 가진 인그레스 컨트롤러를 선택해야합니다. ex. NGINX, Traefix, HAProxy 등등
- API를 외부에 주로 제공한다면 API 기반 워크로드를 세부적으로 조절할 수 있는 Kong 또는 앰배서더와 같은 인그레스 컨트롤러 사용을 고려해야한다.
- 매트릭을 관찰해 인그레스 규모를 적절하게 확장하고, 워크로드가 확장되는 동안 클라이언트 중단을 막을 수 있는 충분한 대비책이 있어야합니다.

## 네트워크 보안 정책
podSelector, ingress, egress, policyType을 설정할 수 있다.

- podSelector: matchLabels를 가진 쿠버네티스 셀렉터와 동일한 규약을 따릅니다.
- ingress: 인바운드 룰을 정의합니다.
- egress: 아웃바운드 룰을 정의합니다.
- policyTypes: 정책 객체와 연관된 네트워크 정책 규칙 타입을 지정합니다. egress는 반드시 명시를 해야하고, ingress는 명시하지 않아도 됩니다.

## 네트워크 정책 모범 사례

- 인그레스의 트래픽을 유심히 보면서 규칙을 수정해나가야 한다.
- 사용 중인 네트워크 플러그인에서 제공하는 자체 인터페이스가 있는지 확인해야한다. (기본 제공하는 기능을 확인해야한다는 것인지?)
- 기본 거부 정책을 자주 사용한다면 각 네임스페이스 단위로 기본 거부 정책이 적용되도록 설정한다.
- 외부에서 접근해야하는 파드가 있는 경우 레이블을 사용해 수신을 허용하는 네트워크 정책을 명시적으로 적용합니다. (추후 추적에 용이하도록 하기 위해서)
- 하나의 정책이 모든 네임스페이스에 적용될 수 있도록 단일 네임스페이스에 애플리케이션 워크로드를 배치해야한다.

>  제한 정책 수가 적은 테스트 네임스페이스를 만들어 정확한 트래픽 패턴을 조사하세요 p.184

테스트 네임스페이스의 트래픽 패턴을 조사해서 어디에 사용하지?? 실제로 요청이 들어오지 않을텐데

## 서비스 메시
서비스 메시: 서비스가 전용 데이터 플레인과 컨트롤 플레인으로 연결하고 보호할 수 있는 법을 제어하는 것이다.

> 시스템 전체에서 입출력되는 엔드포인트의 동적인 특성 때문에 서비스 간의 모든 연결을 관리, 보안, 관찰, 추적하는 것은 상당히 어렵습니다. P.184

> 서비스 메시가 제공해야하는 기능 p.184~p.185

애플리케이션 변경 없이 서비스 메쉬를 구현하기 위해서는 사이드카 프록시를 사용하면 된다. 대표적으로 istio, envoy 등을 사용한다.

Q: 쿠버네티스 세상에서 서비스 모니터링을 잘하기 위해서 사용하는 툴인가??

### 참고문헌
- https://kubernetes.io/ko/docs/tasks/administer-cluster/coredns/
---
### 연결문서
- 


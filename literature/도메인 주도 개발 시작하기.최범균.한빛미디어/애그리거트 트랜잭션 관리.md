### 생성 날짜: 2024-07-02T18:50
### 주제: 애그리거트 트랜잭션 관리
---
### 본문:
DDD가 만능은 아니다 주문 데이터를 수정하는 중간에 사용자가 본인의 배송지를 변경한다면 동시성 이슈가 발생할 수 있다.

이때 취할 수 있는 방법은 2가지 중 하나인데 사용 가능한 방법은 다음과 같다.

  

1. 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다.
2. 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

  

1번은 선점 잠금이고, 2번은 비선점 잠금이다.

  

선점 잠금은 흔히 이해하고 있는 락 개념으로 먼저 점유한 사람이 먼저 수정할 수 있도록 기능을 제공합니다.

jpa를 사용한다면 Lock 어노테이션을 통해 구현할 수 있습니다.

  

하지만, 선점 잠금이 만능은 아닌데요. 선점 잠금은 락을 획득한 주체가 락을 해제하지 않거나 못하는 상황에 빠지면 시스템이 데드락 상태에 처할 수 있습니다.

이에 락의 유휴시간을 사용하는 것으로 임시 대응을 할 수 있는데요.

  

임시 대응이라고 말하는 이유는 유휴시간이 끝날 때까지 작업이 끝나지 않는다면 동시성 이슈가 발생할 수 있어 선점 잠금을 사용하는 이점이 적을 것으로 생각됩니다.

  

비선점 잠금은 락을 사용하지는 않고, version이라는 개념을 도입하여 하나의 테이블에 대한 트랜잭션이 아니라 여러 테이블에 거친 쓰기 작업 또한 동시성 이슈가 발생하지 않도록 할 수 있습니다.

jpa를 사용한다면 Version 어노테이션을 사용할 수 있습니다.

  

Q: 수정이 많은 경우 version을 bigint로 선언하여 끝없이 올라가도록 해야하는 것인가…??

  

루트 엔티티에만 version을 도입한 경우 비선점 잠금이 의도한 것같이 동작하지 않을 수 있는데 이때는 강제 버전 증가를 사용하면 된다.

강제 버전 증가는 OPTIMISITIC_FORCE_INCREMENT를 사용하면 구현할 수 있다. p.262

  

오프라인 선점 잠금을 생각해볼 수 있는데 이것은 데이터 수정 폼에 들어오면 락을 획득하도록 하여 물리적으로 한번에 1명씩만 값을 수정할 수 있도록 합니다.

  

Q: 팟을 기준으로 데이터가 관리되는 것 같은데 팟이 3개 있다면 어떻게 대처하지?

DB, REDIS를 사용하여 LockManager를 구현하면 문제없을 것으로 이해된다.


---
### 참고문헌
- 
---
### 연결문서
- 


### 생성 날짜: 2024-06-22T21:47
### 주제: 응용 서비스와 표현 영역
---
### 본문:

### 표현 영역과 응용 영역
- 표현 영역: 사용자의 요청을 해석하거나 응답을 반환해주고, HTTP 프로토콜에 필요한 쿠키, 헤더 등을 읽거나 쓴다.
- 응용 영역: 비즈니스 로직을 수행한다. ex. 회원 가입, 주문 데이터 생성 등

### 응용 서비스의 역할
응용 서비스는 도메인 영역과 표현 영역을 연결해주는 창고 역할을 수행한다.

> 응용 서비스가 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다. p.203

이 말이 맞다면 코드 중복이 일어나고 있을 확률이 매우 높기 때문에 코드 중복 또는 클래스가 가지고 있는 역할의 범위가 많지는 않은 지 고민해야한다.

> 도메인 로직은 도메인 영역에 위치하고 응용 서비스는 도메인 로직을 구현하지 않는다고 했다. p.204

예를 들어준 것 처럼 암호를 검사하는 로직은 도메인에서 수행되어야한다. 그렇지 않다면 User의 암호를 검사하는 서비스가 늘어남에 따라 domain에서 처리되었으면 1번만 구현하면 되는 것을 여러 번 구현해야하기 때문이다.

대표적으로 들 수 있는 예시가 핸드폰 번호이다. sms 전송을 하기 전에 핸드폰 번호 유효성을 검증하려고 한다면 이를 domain에서 수행하면 코드 중복이 일어나지 않을 수 있다. 
 
 📗: 도메인의 역할이 비대해지는 것인가?? 객체를 입력 받아 내부적으로 데이터를 처리하니까... (코드가 비대해질 것 같다는 생각이 많이 든다)

이에 대해 저자는 다음 2가지 이유를 근거로 들면서 도메인에 코드가 들어가야한다고 한다.
1. 코드의 응집성이 떨어진다. -> 도메인 데이터와 도메인 정보를 조작하는 로직이 떨어져 있으면 도메인 로직을 파악하기 위해 여러 영역을 분석해야한다. <- 이거는 좋네
2. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다. 
	ex. 비정상적인 계정 정지를 막기 위해 암호를 확인한다고 했을 때. 이 경우 계정 정지 기능을 구현하는 응용 서비스는 다음과 같이 암호를 확인하는 코드를 구현해야한다. p.205

### 응용 서비스의 구현
응용 서비스를 구현할 때 다음 2가지 중 1가지 방식으로 구현해야한다.
1. 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
2. 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
우선, 1번 방법으로 구현을 하고 응용 서비스가 비대해지면 2번 방법으로 리팩토링 하는 것이 좋아 보인다.

비대해지거나, 응용 서비스의 역할이 너무 많다는 것은 클래스의 크기로 판단할 수도 있지만 circular dependency가 발생하는 것으로 진단하는 것도 좋을 것 같다. 잘 분리했다면 circular dependency가 발생할 수 없다고 생각한다.

저자는 별필요한 기능까지 포함하게 되므로 2번 방법으로 구현을 하고, 응용 서비스에서는 2~3개의 기능만을 구현할 것을 추천한다.

📗: 비대한 클래스 1개 vs 자잘한 클래스 10개 과연 선택은...??

oh ho: MemberServiceHelper 클래스를 만들어서 repo를 파라미터로 넘기고 내부적으로 검증 로직을 수행한다.

TDD를 한다면 interface를 구현하는 것이 좋을 수 있지만 mockito를 사용하는 경우 굳이 그렇게 까지 안해도 된다. 

TDD는 이상적인 개발 방법론이라고 생각한다. 이상적이라고 생각하는 이유는 TDD가 좋은 것은 알지만 실천하는 사람은 없기 때문에.  나는 구현 -> 테스트 -> 수정 방식도 훌륭하다고 생각한다.

응용 서비스에서는 필요한 파라미터만 전달 받으면 되는데. 저자는
> 응용 서비스에 데이터로 전달한 요청 파라미터가 두 개 이상 존재하면 데이터 전달을 위한 별도 클래스를 사용하는 것이 편리하다. p.213

위와 같이 설명한다. 나 또한 이에 대해 동의를 하는데 그 이유는 짜잘한 검증 음수 입력 불가, 빈 문자열 입력 불가와 같은 검증을 해당 객체에서 진행할 수 있고, 이는 다른 응용 서비스에서 함수를 호출할 때에도 항상 올바른 값이 들어온다고 장담할 수 있기 때문이다.

tmi) protobuf 정의 내역을 보면 정수형이여야하는데 문자로 들어오는 경우가 매우 많은데 이와 같이 문자가 모든 경우를 커버해준다고 막무가내로 선언하는 것은 매우 조심해야한다. 비즈니스 로직 상 어쩔 수 없는 상황이라고 하면 oneof를 사용해서 구현하는 것이 좋다고 생각한다. (protobuf인 경우)

---

> 응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편할 수 있지만 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 된다. p.215

동의한다. 응용 서비스에서 도메인을 리턴하는 경우는 다른 애그리거트를 수정할 필요가 있기 때문인데. 이를 해결하기 위해 도메인 서비스 로직을 잘 작성하면 어떤 응용 서비스에서도 애그리거트를 리턴할 필요가 없다.

저자의 의견은 확고한데
> 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법이다. p.215

라고 덧붙인다.

📗: 실제로 팀 내에서 다른 애그리거트를 수정하기 위해 도메인을 반환하는 함수가 꽤 많고, 이를 지속적으로 구현하다보면 circular dependency가 생겨 ~Facade 형태의 클래스를 지속적으로 생성해나간다. 저자의 의견과 같이 응용 서비스에서 애그리거트를 반환하는 것은 단기적인 관점에서 이득일 수 있자만 추후 유지보수를 점차 어렵게 만드는 거버넌스로 진화하는 것 같다는 생각을 많이 했다.

응용 서비스에서 애그리거트를 반환해도 된다고 하면 반대로 표현 영역의 코드가 서비스를 넘어 애그리거트까지 입력되어도 되는가?? 를 반문해보는 것도 좋을 것 같다.

serveltRequest, servletResponse를 처리하는 도메인, 엔티티를 상상해보자

### 표현 영역
표현 영역의 책임은 다음과 같다.
1. 사용자가 시스템을 사용할 수 있는 흐름을 제공하고 제어한다.
2. 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
3. 사용자의 세션을 관리한다.

### 값 검증
값 검증은 응용 서비스와 표현 영역 두 곳에서 모두 실행할 수 있는데 다음과 같이 검증을 수행할 수 있다.
- 표현 영역: 필수 값, 값의 형식, 범위 등을 검증한다.
- 응용 서비스: 데이터의 존재 유무와 같이 논리적 오류를 검증한다.
즉, 알맞은 값이 들어왔는지는 표현영역에서 검증을 하고, 응용 서비스에서는 비즈니스 로직에 근거한 검증을 수행한다. ex. 회원은 최근 3개월 내에 사용한 비밀번호를 사용할 수 없습니다. 등

-> 저자는 마지막에 응용 서비스에서 그냥 다 검증한다고 말한다.
-> 나는 파라미터 객체에서 표현 영역의 검증을 수행하고, 응용 서비스에서는 말한 것 같이 논리적 오류를 검증하는 것이 좋다고 생각한다.

### 권한 검사
응용 서비스에서 검증을 진행하던가 spring security를 활용하자.

### 조회 전용 기능과 응용 서비스
> 이 경우라면 굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 문제가 없다. p.231

동의하지 않는다. 지금까지 응용 서비스와 애그리거트 사이에 역할을 매우 강조를 하면서 레이어드 아키텍처의 중요한 원칙 중에 하나인 바로 아래 레이어만 참조하는 것을 지키지 않아도 된다고 말하는게 어불성설 같다.

---
### 참고문헌
- 
---
### 연결문서
- 


### 생성 날짜: 2024-06-18T20:00
### 주제: 리포지터리와 모델 구현
---
### 본문:

## JPA를 이용한 리포지터리 구현
> 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치 시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다. p.131

JpaRepository를 합성하는 interface들이 domain에 위치해야하는 것을 이해했지만 위 말은 패키지 경로만으로도 의존이 낮아지는 것처럼 느껴진다.

> null을 사용하고 싶지 않다면 다음과 같이 Optional을 사용해도 된다. p.131

java는 모든 변수가 null이 가능하지만 kotlin은 그렇지 않다. 그렇다면 findById 함수를 구현할 때 Any?와 같이 구현하면 null가 null이 아닌 값을 모두 입력 받을 수 있다.

📡 Kotlin ? 연산자와 Optional 중에 어떤 것을 더 선호하는지?

## 스프링 데이터 JPA를 이용한 리포지터리 구현

> @AttributeOverrides 애너테이션을 이용해서 Orderer의 memberId 프로퍼티와 매핑할 칼럼 이름을 변경했다. p.141

테이블의 컬럼 이름과 객체 맵핑 시 사용하는 이름을 다르게 설정할 수 있다. 읽기 좋은 코드를 만들기 위해서 적재적소에 사용하면 좋을 것 같다.

하지만 Embedded 타입에 사용하는 경우 annotation 지옥이 펼쳐질 수 있을 것 같으니 유의해야한다. (p.141 참고)

이후 내용
1. 기본 생성자 제공이 필요하다.
	1. 기본 생성자로 객체를 생성한 후에 setter를 호출하여 객체를 완성해주기 때문이다.
	2. kotlin의 경우 gradle.build.kts 파일에 noArgs 타입을 지정해주면 기본 생성자가 만들어진다.
2. protected setter가 필요하다.
	1. private setter <- JPA 모델 맵핑 시에 알아내지 못함
	2. public setter <- 내부 데이터를 외부에서 변경할 수 있기 때문에 캡슐화를 깨뜨린다.
3. 타입 변경이 필요한 경우 AttributeConverter를 선언하여 사용해줄 수 있다.
	1. auto_apply 옵션을 활성화하는 경우 해당 타입을 사용하는 곳에 자동 적용
4. value collection의 경우 ElementCollection과 CollectionTable을 사용하여 구현해줄 수 있지만 OneToMany로 맵핑을 하는게 더 좋아 보인다.

#### 밸류를 이용한 ID 맵핑
composite key, 특정 컬럼을 ID로 사용하고 싶은 경우 EmbeddedId를 사용할 수 있고, 이 어노테이션을 사용할 때 유의사항은 다음과 같다.
1. Serializable 타입이여야한다.

📡 p.152 예시와 같이 주문 세대를 구분하기 위해 EmbededId를 사용하는 것은 좋아 보인다.

> 루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야 한다. p.152
> 밸류가 아니라 엔티티가 확실하다면 해당 엔티티가 다른 애그리거트는 아닌지 확인해야 한다. p.152
> 별도 테이블로 저장하고 테이블에 pk가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 항상 고유 식별자를 갖는 것은 아니기 때문이다. p.153

저자는 애그리거트 내에서는 루트 엔티티가 1개 뿐이여야 함을 말하는 것 같다.

경험이 부족한 것일 수 있지만 엔티티가 아닌 밸류라고 하더라도 엔티티로 선언하여 연관관계 맵핑을 사용하는 것이 ElementCollection, CollectionTable 등을 사용하는 것보다 읽기 좋다고 생각한다.

위 어노테이션을 사용해서 얻을 수 있는 단점은 애그리거트 내에서 연관관계 맵핑을 사용하는 경우 하위 엔티티(밸류)를 불변으로 유지할 수 없다가 있을 것 같다...

하지만 동시에 같은 애그리거트 내에서 하위 엔티티가 같이 변경되지 않는 경우가 얼마나 많을까?? 라는 생각도 든다. 결국, pros and cons

📡 밸류를 유지하기 위해 사용되는 많은 어노테이션을 이해하는 것보다는 엔티티로 정의하는 것이 좋다고 생각한다.

#### 밸류 컬랙션을 Entity로 맵핑하기
wow 특정 식별자 컬럼을 기준으로 적절한 구현체를 반환하는 기능을 사용할 수 있다.

- Inheritance: 상속 전략을 나타내는 어노테이션으로 SINGLE_TABLE을 사용하면 상속에 상속은 방지된다. (진짜...??)
- Discriminator: 어떤 컬럼을 기준으로 구현체를 구분할 건지 나타내는 어노테이션
- DiscriminatorValue: Discriminator에 선언된 컬럼의 값을 나타낸다.

📡 OneToMany 맵핑을 사용하는 경우 clear 함수를 호출하면 n+1 쿼리가 발생한다. 반면에 Embeddable 타입에 대한 컬랙션을 clear 할 때는 1번의 쿼리로 delete 를 수행한다. <- 요거 실행해봐도 재밌을 것 같다!

#### 애그리거트 로딩 전략
fetch type eager를 사용하는 경우 join을 사용하여 데이터를 가져온다. 이때 카타시안 조인을 사용하기 때문에 조회 대상이 많아질 수록 쿼리 실행 속도가 현저히 낮아질 것 같다.

위와 같은 이유 때문에 묻지도 따지지도 않고, fetch type lazy를 사용하는 것 같기도 하다.

#### 애그리거트의 영속성 전파
- persist: 같이 생성하고 싶을 때
- remove: 같이 삭제하고 싶을 때
#### 식별자 생성 기능
- 사용자 직접 생성, 도메인 로직으로 생성: pk 기반으로 range 검색이 없다면 UUID도 좋은 선택일 것 같다.
- DB를 이용한 일련번호 사용: 관계형 데이터베이스에서 auto_increment는 매우 유용하지만 그만큼 데이터베이스에 부하를 많이 줄 것 같다. (insert가 매우 많은 테이블에서 auto_increment가 잘 동작하기 위해서는 짧은 순간순간마다 테이블 락이 걸려야할 것 같다. 실제로 세션이 여러 개 있어도 id는 unique하게 채번된다.)

#### 도메인 구현과 DIP

> p.171

동의한다. infrastructure와 domain 간 JPA 의존 없이 순수하게 유지할 수 있겠지만 불필요한 작업이라고 생각한다. spring boot를 사용하면서 JPA를 사용하지 않는 것은 작업의 속도 측면에서 매우 불리하다. 

물론, 더 좋은 기능을 가진 ORM이나 기술이 나올 수 있겠지만 지금까지의 경험으로 미뤄볼 때 순수하게 유지하여 분리할 수 있게 되어도 분리할 시간도 없거니와

관게형 데이터베이스에서 noSQL로 전환되는 느낌이라면 새롭게 구현하는 것이 더 좋을 것 같다는 생각이 든다.

---
### 참고문헌
- 
---
### 연결문서
- 


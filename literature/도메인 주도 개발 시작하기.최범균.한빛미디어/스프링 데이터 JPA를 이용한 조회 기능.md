### 생성 날짜: 2024-06-19T20:17
### 주제: 스프링 데이터 JPA를 이용한 조회 기능
---
### 본문:

> 명령 모델과 조회 모델을 분리하는 패턴 p.174

create, delete, update는 항상 동시성 이슈가 발생하고, get은 항상 성능 문제를 일으키는 것 같다.

### 검색을 위한 스펙

JPA는 인터페이스를 정의하는 것만으로도 구현체를 만들어준다. 하지만 이는 다양한 검색 조건이 필요한 경우 매우 많은 함수를 정의하게 만들 수 있는데 이때 활용해볼 수 있는 것이 스펙이다.

📡 자세하게 이해하기 전에 바라본 스펙은 querydsl을 완전히 사용하지 않아도 동적 쿼리를 생성할 수 있는 기능인가?? 하는 생각이 들었다.

JpaRepository를 상속하여 메서드를 override 해줄 수 있지만 p.176 이는 모든 데이터를 메모리에 불러오고 난 후에 filter 처리를 하는 것이라 근본적으로 query를 수정해서 실행하는 것은 아니다... soooo bad

### 스프링 데이터 JPA를 위한 스펙 구현

JPA는  Specification 인터페이스를 제공해주고 있었는데 toPredicate 함수를 override 하면 검색 조건을 표현할 수 있다.

p.181 쪽의 예제를 보면 orderDateBetween JPA 기본 인터페이스를 활용하면 아래와 같은 쿼리를 생성하지 못하는데 이를 잘 활용하면 대부분의 경우를 커버할 수 있을 것 같다.

```
// 생성 불가
select * from order where <parameter> between order_start_date to order_end_date
```

### 리포지토리/DAO에서 스펙 사용하기

p.182와 같이 구현하면 초반에 말한 메모리에 모든 데이터를 올리지 않는 것인지?? 실제 실행 쿼리를 한번 보는 것도 좋을 것 같다는 생각이 들었다!

### 스펙 조합

- and(), or() 함수를 사용하여 스펙을 조합할 수 있다.
- not() 함수를 사용하여 부정 연산을 사용할 수 있다.
- where 함수를 사용하면 조건에 null이 오는 경우 스펙 객체를 생성하지 않고, 값이 있으면 스펙 객체를 생성한다.
queryDsl과 구현이 같은 거 아닌가...?? querydsl도 specification 객체를 사용하여 구현된 것은 아닌지??!

### 정렬 지정하기
- 함수 이름을 사용하여 정렬 조건을 넣을 수 있다. ex. ...OrderNameDescOrderDateAsc
- Sort를 인자로 전달

p.186 마지막 예제를 보면 Sort 조건을 위해 매우 길게 정의되는 것을 볼 수 있는데 매번 비즈니스 로직에서 Sort를 생성해서 넣어주는 것보다는 함수 이름이 길더라도 만드는 게 좋을 것 같다는 생각이 들었다.

### 페이징 처리하기

- Pageable 객체를 넘겨서 페이징 처리를 할 수 있다.
	- page: 0 번이 첫번째 페이지이다.
	- pageable 객체를 넘기면 쿼리가 2개 나간다. 전체 개수를 구해야하기 때문에

p.189를 보면 pageable을 사용하는데 List로 반환하는 함수를 구현하는 것이 맞는가??
- 이렇게 사용하는거는 코드 리뷰 단계에서 쳐내야한다고 생각한다.

spec, pageable을 사용하는 경우는 List를 반환해도 count 쿼리를 실행하는데 이것도 왜 실행하는지 이해가 잘 되지 않는다.

### 스펙 조합을 위한 스펙 빌더 클래스

확장 함수로 구현도 가능하겠지만 빌더를 만드는 것이 휠씬 좋아 보인다...

확장 함수는 매우 간편하지만 코드를 읽기 어렵게 만든다고 생각하기 때문에 최근에 sorting 함수에서 sorting + 객체 추가하는 구현도 봤다. (당연한게 당연하지 않게 되는 매직...)

### 하이버네이트 subselect

특정 쿼리의 조회 결과를 Entity로 정의하고 싶은 경우 사용할 수 있다. 하지만 그냥 문자열이 들어가는 만큼 유지보수는 어려울 것 같다..

> @Subselect를 사용해도 일반 @Entity와 같기 때문에 EntityManager#find(), JPQL, Criteria를 사용해서 조회를 할 수 있다는 것이 @Subselector의 장점이다. p.197

이거는 인정한다. 문자열 관리만 될 수 있다면 Subselector는 매우 강력한 기능이 될 것이다.

---
### 참고문헌
- 
---
### 연결문서
- 


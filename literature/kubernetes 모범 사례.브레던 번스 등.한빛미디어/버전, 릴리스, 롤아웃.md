### 생성 날짜: 2024-03-31T17:31
### 주제: 버전, 릴리스, 롤아웃
---
### 본문:

> 전통적인 모놀리식 애플리케이션은 시간이 흐르면서 규모가 방대해지기 때문에 비즈니스 요구사항의 속도에 맞춰 업그레이드, 버전 관리, 변경을 하기가 어렵습니다. P.119

특정 도메인은 분리가 되는 것이 확실하게 장점이 있다고 생각합니다. (인증/인가, 결제, 예약 etc...)
하지만 도메인 단위로 프로젝트가 분리된 단계(MSA를 하려는 단계에서)에서 충분한 리소스가 투입되지 않으면 어차피 각 도메인의 프로젝트는 다른 도메인의 기능이 필요하기 때문에 MSA가 무색하게 다른 도메인의 기능을 구현하게 됩니다.
(ex. 차량 리스트 조회해야하는데 카셰어링팀 바쁘네,,, 우리가 구현해야겠다.)

## 버전
시멘틱 버전을 사용하자 메이전 버전, 마이너 버전, 패치 버전으로 구성이 된다. 각 팀에서는 버전을 어떤 경우에 올리는 지??

- 메이저 버전: 이전 버전에 구현된 API를 대부분 호환하지 못하는 경우
- 마이너 버전: 정기 배포 시마다 무조건 1 증가
- 패치 버전: 비정기 배포 시마다 무조건 1 증가, 마이너 버전 올라가면 다시 0으로 초기화

## 릴리스
> 보통 디플로이먼트 metadata.labels 명세나 pod.spec.template.metadata.label 명세에 릴리스 정보를 넣습니다. p.120

이번에 grpc 서버를 구축하면서 깨달은 것은 deployment에 pod.spec.template.metadata.label에 값을 넣어줘야 pod이 새롭게 생성될 때 metadata.label에 적절한 값이 들어간다.

> 레이블 셀렉터를 생성한 후에는 변경할 수 없다는 점을 이해해야 합니다. 즉 새로운 셀렉터를 추가하고 파드의 레이블을 매치했을 때, 기존 레플리카셋이 업그레이드되는 것이 아니라 새로운 레플리카셋이 만들어집니다. P.121

잘 이해가 되지 않았다.
Q: 레이블 셀렉터의 역할은 무엇이지? 

## 롤아웃
>디플로이먼트 컨트롤러가 등장하기 전에 쿠버네티스 컨트롤러 프로세스가 애플리케이션을 롤아웃하는 유일한 방법은 커맨드라인 인터페이스로 특정 replicaController에 대해 kubectl rolling-update 명령을 내리는 것이었습니다. P.121

deployment, ingress 등 헬름차트에 작성하는 것은 모두 명세이고, 각각의 스펙으로 실행되는 Controller가 실행되어 있는 형태인지? 갑자기 궁금해졌다.

cli로만 update를 진행했고, 이를 타개하고자 디플로이먼트 개념이 도입되었다.

> 초기의 쿠버네티스 사용자는 종종 이를 오해하여 디플로이먼트 메나데이터 필드 안에 레이블을 변경하고, 매니페스트를 다시 적용했을 때 업데이트가 일어나지 않으면 당황하고는 했습니다. P.121

나야나

- maxUnavailable: 충분한 수의 새로운 파드가 온라인 상태가 되기 전까지 이전 파드가 제거되지 않도록 막는 값
- maxSurge: 특정 수의 이전 파드가 제거되기 전까지 새로운 파드가 생성되지 않도록 막는 값입니다.

> 새로운 파드가 온라인이 되기를 기다리는 동안 메시지는 큐에서 대기하며, 온라인으로 전환되자마자 메시지 처리가 재시작됩니다. p.122

어떤 메시지를 말하는 것인지?? 쿠버네티스 내부적으로 메시지 큐를 사용하여 통신을 하는 것인가??

## 버전, 릴리스, 롤아웃 모범 사례
- 애플리케이션 전체에 시멘틱 버전을 사용하세요.
- 디플로이먼트 메타데이터 내의 릴리스와 릴리스 버전/숫자 레이블을 사용해 CI/CD 파이프라인 릴리스를 추적하세요.
- 디플로이먼트 패키지 서비스로 헬름을 사용하고 있다면 헬름 차트와 함께 롤백이 되거나 업그레이드될 서비스를 함께 묶을 수 있도록 각별히 주의하세요.

---
### 참고문헌
- 
---
### 연결문서
- 


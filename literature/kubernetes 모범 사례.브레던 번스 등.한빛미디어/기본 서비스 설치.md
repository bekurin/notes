### 생성 날짜: 2024-03-23T09:39
### 주제: 기본 서비스 설치
---
### 본문:

> 쿠버네티스에서는 모든 것을 선언적으로 표현합니다. 즉, 클러스터 내에서 애플리케이션의 의도한 상태를 작성하며 애플리케이션의 모든 구성 요소에 대해 상태를 정의합니다. p.20

쿠버네티스의 강력한 장점 중 하나라고 생각합니다. 예를 들어 최소 정상적인 상태의 팟이 2개 이상있어야한다고 가정하면 쿠버네티스는 이 상태를 만들기 위해 100번이고, 1,000번이고 팟을 재시작할 것입니다.

선언적이 아닌 명령적으로 사용하는 경우에 대한 단점을 저자는 다음과 같이 설명합니다.
> 클러스터가 어떻게 특정 상태가 되었는지 이해하고 그대로 복제하는 것이 어려워집니다. 마찬가지로 애플리케이션에서 발생한 문제를 이해하고 해결하는 것도 어려워집니다. p.20

명령적 구성에 대한 저자의 생각을 조금 더 간략하게 정리하자면 "문제가 발생했을 때 정확한 모니터링과 디버깅을 하기 어려워진다" 입니다.

그도 그럴 것이 모니터링과 디버깅을 위해서는 가설을 설정하고 검증을 해야하는데 명령적 구성은 가설을 세우기가 매우 어려워집니다. 독립 변수로 설정할 수 있는 것이 개수가 줄어들기 때문입니다.

## 이미지 관리 모범 사례

> 이미지 구축 과정은 '공급망 공격'에 취약합니다. 공급망 공격이란 신뢰할 수 있는 소스의 의존 이미지에 악의적인 사용자가 코드나 바이너리를 사입해서, 결국 독자의 애플리케이션에 이를 내장시키는 겁니다. p.22

공급망 공격과 관련한 사례를 챗지피티 4.0에게 물어봤습니다.

 2018년에 Docker는 사용자의 서버에 역방향 쉘과 암호화폐 채굴기를 설치하는 데 사용된 17개의 백도어가 설치된 컨테이너 이미지를 Docker Hub에서 제거했습니다. 이러한 악성 패키지 중 일부는 수백만 번이나 설치되었으며, 문제의 규모를 강조합니다. 이 이미지들은 Docker 팀이 내려가기 전까지 약 1년간 Docker Hub에 활성 상태로 남아 있었습니다​.
- https://www.bleepingcomputer.com/news/security/17-backdoored-docker-images-removed-from-docker-hub/#google_vignette
Docker Hub의 최소 30개의 악성 이미지가 총 2천만 번 다운로드되어 암호화폐 채굴 악성 소프트웨어를 퍼뜨리는 데 사용되었습니다. 이 작업으로부터 약 20만 달러의 암호화폐 채굴 수익이 발생했으며, 주로 Monero 암호화폐가 사용되었습니다. Docker Hub가 리포지토리로서의 인기 때문에 공격자들이 자신들의 악성 소프트웨어를 널리 전파하는 유혹적인 대상이 되었습니다.
- https://threatpost.com/malicious-docker-cryptomining-images/165120/

결론 CI 과정에서 도커 이미지에 사용될 runner image나 라이브러리의 사용을 조심해야한다.

## 애플리케이션 레플리카 생성

레플리카 생성 시에 replicaSet을 사용하는 대신 Deployment 사용을 권장하는데 그 이유는 ReplicaSet은 버전 관리, 롤링 업데이트, 롤백 기능을 제공합니다.

> 쿠버네티스 리소스 모델을 더욱 잘 이해하게 되면 요청과 제한을 다르게 설정할 수 있습니다.
- requests: 애플리케이션을 실행하는 호스트 장비가 보장해주는 리소스 크기
- limits: 컨테이너가 사용할 수 있는 최대 리소스 크기

requests: 0.5 core, limits: 1.0 core, autoscaling: cpu usage 80%로 설정하면 언제 오토스케일링이 일어날까요?

> 인그레스를 배치하면 향후 서비스 확장 측면에서 유연성을 확보할 수 있습니다. p.25

인그레스를 사용해서 서로 다른 서비스를 호출하도록 할 수 있기 때문으로 생각됨
Q: 인그레스와 로드 밸런서의 차이는 무엇이지??
- 인그레스는 어떤 서비스로 갈지에 대해 집중한다면 로드 밸런서는 골골루 요청을 흘리는 것에 집중하는 것??

> 클러스터에서 인그레스가 동작하려면 서비스 리소스와 달리 인그레스 컨트롤러 컨테이너가 필요합니다. p.26

결국에 인그레스는 명세일 뿐 실제로 동작하는 인그레스 컨트롤러 컨테이너가 뒤에서 실행된다.

## 컨피그맵으로 애플리케이션 설정

> 유럽에서는 부활절을 특별하게 여기지만, 중국에서는 춘절이 더 특별합니다. 나라마다 각각 다른 날에 특별 화면을 보여줘야 할 겁니다.

config map을 활용하여 국가마다 아니면 지역마다 특수한 설정이 들어가야하는 경우 config map을 활용하면 좋을 것 같다는 생각이 들었습니다.

config map을 무지성으로 변경하게 되면 health check를 통해 불시에 팟 재시작이 일어날 수 있습니다. config map에 버전 개념을 추가하면 이런 일을 사전에 방지할 수 있습니다.

## 시크릿 인증 관리

> 시크릿이 소스 코드나 이미지에 단단히 결합되어 있다면 각 환경마다 다른 이미지가 필요합니다. p.29

테스트가 마찬가지로 힘들어지게 될 것으로 파악되고, 저자가 말한 위 예시를 테스트 하기 위한 설정 값이 코드에 있다면 application-유럽.yaml, application-중국.yaml를 각각 정의하여 할 것 같습니다.

## 간단한 스테이트풀 데이터베이스 배포
팟 재시작 시에 손상되지 않는 불륨을 만들기 위해서는 원격 퍼시스턴트불륨(PersistentVolume)을 사용하면 된다.

## 서비스를 이용한 TCP 로드 밸런서 생성
> 헤드리스 서비스는 클러스터 IP 주소를 가지지 않습니다. 대신 스테이트풀셋 안의 모든 파드에 대한 DNS를 설정합니다. 즉 redis-0.redis-write라는 DNS 이름으로 레디스 마스터에 접근할 수 있습니다.

쿠버네티스 내부적으로는 dns를 통해 통신을 한다. (socar-server 같은 거 돌리려면 포트포워딩 해야하는데 비슷한 형식으로 생각된다) 
Q: 내부적으로 어디가 어디인지 파악할 수 있는 dns 서버 같은게 있어야할 것 같은데 어디에 존재하는 지 궁금하다.

## 인그레스를 이용해 트래픽을 정적 파일 서버로 전달
> / 경로를 /api 경로 이후에 두는 것을 명심해야 합니다.

ingress에서 어떤 서비스로 갈지 파악하는 것은 위에서부터 아래로 실행되는 것으로 파악된다.

---
### 참고문헌
- 
---
### 연결문서
- 


> 마침내 지뢰가 없다고 확신한 병사는 몸을 일으켜 큰 걸음으로 성큼성큼 걷기 시작한다. 그순간, 지뢰를 밟아 병사의 몸이 산산조각 난다. p.282

몇 번 검증했다고 해서, 테스트 코드를 작성했다고 해서 모든 프로그래밍이 정상 동작하지는 않을 수 있다.

테스트 코드가 결국 입력 값이 매번 변경되지 않는다면 로컬에서 몇 번 검증한 것과 크게 다르지 않기 때문에...
### 구현에서 생기는 우연
> 만든 사람이 생각조차 못했던 경우인 것이다. P.283

구현한 사람이 비즈니스 로직에 대해서는 완벽하게 테스트를 작성하고 코드로 구현했지만 올바르지 않은 파라미터가 넘어오는 것을 예상하지 못했다면..??
### 비슷하다고 괜찮을 리는 없다\
나라가 큰 경우 도시에 따라 시간대가 다른데 1시간 정도는 차이가 나도 괜찮다는 생각을 한다면 점점 코드가 복잡해질 것이다.

어디는 LocalDateTime, ZonedDateTime을 사용하고, 어떤 API는 현지 시간을 파라미터로 입력 받고, 어떤 API는 UTC를 기준으로 입력 받는다면 코드를 구현할 때마다 또는 코드를 유지보수 할 때마다 머리가 복잡해질 것이다.

이런 경우는 시간을 다루는 정적 객체를 만들어서 구현을 잘 캡슐화할 수 있도록 하자.
### 유령 패턴
1,000번의 1번 꼴, 테스트 기기에 대한 차이로 인해 확률적으로 발생하는 버그를 유령 패턴으로 말하고, 이런 것들을 증명하는 과정은 시간은 많이 소요하겠지만 개발자로써 유익할 것 같다.
ex. LocalDateTime을 사용하는 경우 Clock 객체가 기기에 따라 다르게 주입 되는데 linux, macos에서 Clock 구현체가 달라. 테스트를 작성하면 micro 초 유무가 다르다.
### 상황에서 생기는 우연
1. 사용자 언어가 항상 한구겅일까?
2. 사용자가 글을 읽을 수 있나?
3. 어떤 환경 변수가 항상 존재할 수 있나?
4. 어떤 환경에서도 네트워크가 특정 속도 이상일 수 있나?
5. 인터넷에서 복사 붙여넣기 한 코드를 신뢰하지는 않나?
### 암묵적인 가정
?
### 의도적으로 프로그래밍하기
1. 언제나 여러분이 지금 무엇을 하고 있는지 알아야한다.
2. 나의 구현을 설명할 수 있는가?
3. 계획을 세우고 그것을 바탕으로 진행하라.
4. 신뢰할 수 있는 것에마 기대라.
5. 가정을 기록으로 남겨라.
6. 코드 뿐 아니라 여러분이 세운 가정도 테스트해 보아야 한다.
7. 노력을 기울일 대상의 우선순위를 정하라.
8. 과거의 노예가 되지 말라.
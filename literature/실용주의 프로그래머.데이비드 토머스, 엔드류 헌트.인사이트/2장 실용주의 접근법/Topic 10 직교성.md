> '직교성'은 기하학에서 빌려 온 용어다. 그래프의 축과 같이 두 직선이 직각으로 만나는 경우 직교한다고 말한다.

저자가 직교 개념을 들고 온것은 직교하는 두 직선은 영원히 뻗어가도 서로가 서로에게 영향을 미치지 않는 다는 것을 마치 소프트웨어에서 '독립적'으로 기능 구현을 해야 영향이 적다는 것을 표현하고 싶어 그런 것이 아닌가 생각이 든다.

> 잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스와 서로 직교할 것이다. p.55

데이터베이스와 비즈니스 로직이 서로 직교한다는 것은 어떤 드라이버를 선택해도 or 어떤 데이터베이스를 선택해도 비즈니스 로직에는 영향이 없다는 것을 의미한다.

하지만 모든 것이 좋아 보이는 직교성은 사실 매우 지키기 어려울 수 있는데. 예를 들어 스프링 부트에서 사용하는 Transactional 어노테이션도 사실은 데이터베이스에 매우 종속적인데 이를 분리하기 위해서는 여러 이점을 포기해야한다. 따라서 무조건적으로 독립적인 것을 선호하기 보다는 항상 시간과 비용을 잘 계산한 선택을 하는 것이 좋을 것 같다는 생각이 든다.

> 간단한 컴포넌트를 설계하고, 코딩하고, 테스트하고 그러고는 잊어버릴 수 있다. P.57

독립적이고, 잘 설계된 컴포넌트의 장점이라고 생각한다. 무조건적인 직교를 지향하는 것보다는 위와 같이 세부 구현을 잘 숨겨 테스트에 용이하게 코드를 구현하는 것도 방법이라고 생각한다.

++ 어떤 모듈에 장애가 발생해도 시스템 내부의 모든 코드를 변경하지 않아도 된다.

---
### 설계
> 계층 구조는 직교적 시스템을 설계하는 경력한 방법이다. 각 계층은 자기 바로 밑에 있는 계층이 제공하는 추상화만을 사용하기 때문에, 다른 코드에 영향을 끼치지 않으면서 기반 구현들을 변경할 수 있게 되어 유연성이 높아진다. p.59

내가 생각하는 레이어드 아키텍처에서 지켜야하는 절대적인 규칙이다. 이를 위해 현재 팀에서는 도메인 서비스라는 개념을 도입하고

**internal service**
controller
service
repository + domain service

**public service**
controller
service
infrastructure

위와 같이 설계를 진행하고 있다.
이렇게 구현하면 하나의 기능에 여러 application service가 영향을 받지 않고, 기능 추가에 대해 영향 받을 클래스의 개수를 어림짐작할 수 있다.

### 코딩
코드를 작성할 때 직교성을 유지하기 위해서 저자는 다음 항목을 지킬 것을 제안한다.

- 코드의 결합도를 줄여라: 객체의 상태를 바꿀 필요가 있다면 여러분을 위해 객체가 직접 상태를 바꾸게 하라. <- 객체지향적인 사고방식이라고 생각한다.
- 전역 데이터를 피하라
- 유사한 함수를 피하라
> 안타깝게도 지식은 고정적이지 않다. p.42

정부의 규제, 의뢰인의 단순 변심 등 기획은 확정될 수 없다.
-> 기획 확정 -> 디자인 확정 -> 기능 구현 의 순으로 소프트웨어가 유지보수 될 수 없다는 것을 이해해야한다.

변화하는 요구사항 속에서도 비즈니스 로직이 코드에 잘 스며들어있어야 그때그때 변경을 가하기 쉬울 것이다.

이렇듯 소프트웨어에 신뢰성을 높이기 위해서는 DRY 라고 부르는 원칙을 생각해야한다.
> DRY: Don't Repeat Yourself (반복하지 마라) p.43

저자는 이를 "모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다." 라고 표현한다.

말하고 싶은 바는 단순히 코드의 중복을 피하라는 것이 아니다. 비즈니스 로직 상에 의미하는 바가 같은 코드가 중복으로 들어가지 말라는 것이다.

게임 보드의 row, col를 검증하는 코드가 있다고 할 때
1. row의 범위는 0부터 게임 보드의 최대 row를 넘을 수 없다.
2. col의 범위는 0부터 게임 보드의 최대 col을 넘을 수 없다.

와 같이 2가지 검증 로직이 있을 때. 범위를 계산한다는 관점에서 해석하면 하나의 검증 로직이 존재하면 될 것이다. row, col의 관점에서 해석을 하면 각각의 검증 로직을 각각이 가져야할 것이다.

> 코드는 동일하지만 두 함수가 표현하는 지식은 다르다. 두 함수는 각각 서로 다른 것을 검증하고 있지만, 우연히 규칙이 같은 것뿐이다. 이것은 우연이지 중복이 아니다. p.47

단순히 텍스트가 중복되는 것을 방지하지 말고, 비즈니스 로직이 단 한번만 애매하지 않게 구현될 수 있음을 추구하라.

### 데이터의 DRY 위반
클래스 내부의 필드로 계산할 수 있는 값이라면 public 함수로 제공할 수 있도록 하자.
###  표현상의 중복
open api, spring restdocs 등을 사용하여 문서화를 할 수 있도록 하자.
### 개발자 간의 중복
이미 구현되어 있는 로직을 두번 구현하지 않도록 코드 리뷰 단계에서 소통을 잘 할 수 있도록 하자.
-> 아묻따 어푸를 조심하자.

나는 팀 내 다음과 같은 합의가 무조건적으로 이뤄져야한다고 생각한다.
> 다른 사람이 여러분의 코드를 들여다보고 건드린다고 해서 기분 나빠하지 말 일이다. p.53